//! Disassembly result type

use crate::{analysis, ast};

/// Representation of a static disassembly of a valid instruction.
///
/// A `Disasm` includes the following information:
///
///  * AST representation of the disassembled instruction, primarily intended
///    for user display.
///  * Offset to the next instruction. For most architectures, this is
///    equivalent to the length of the current one. For architectures with non-
///    arithmetic PCs, this is exclusively an offset to be added to obtain the
///    next instruction.
///  * Indication of the control flow of the given instruction.
///  * A list of references generated by this instruction.
///
/// It is only appropriate to return a `Disasm` if an actual disassembly was
/// made of a given instruction. An error type is provided for indicating that
/// disassembly failed for various possible reasons.
pub struct Disasm<I, SI, F, P, S>
where
    P: analysis::Mappable,
{
    instr: ast::Instruction<I, SI, F, P>,
    next_offset: S,
    flow: analysis::Flow,
    targets: Vec<analysis::Reference<P>>,
}

impl<I, SI, F, P, S> Disasm<I, SI, F, P, S>
where
    P: analysis::Mappable,
{
    pub fn new(
        instr: ast::Instruction<I, SI, F, P>,
        next_offset: S,
        flow: analysis::Flow,
        targets: Vec<analysis::Reference<P>>,
    ) -> Self {
        Disasm {
            instr: instr,
            next_offset: next_offset,
            flow: flow,
            targets: targets,
        }
    }

    pub fn as_instr(&self) -> &ast::Instruction<I, SI, F, P> {
        &self.instr
    }

    pub fn iter_targets(&self) -> impl Iterator<Item = &analysis::Reference<P>> {
        self.targets.iter()
    }

    pub fn flow(&self) -> analysis::Flow {
        self.flow
    }
}

impl<I, SI, F, P, S> Disasm<I, SI, F, P, S>
where
    P: analysis::Mappable,
    S: Clone,
{
    pub fn next_offset(&self) -> S {
        self.next_offset.clone()
    }
}

impl<I, SI, F, P, S> Disasm<I, SI, F, P, S>
where
    P: analysis::Mappable,
    ast::Instruction<I, SI, F, P>: Clone,
    S: Clone,
{
    pub fn directive<MV>(&self) -> ast::Directive<I, SI, F, P, MV, S> {
        ast::Directive::EmitInstr(self.instr.clone(), self.next_offset.clone())
    }
}
