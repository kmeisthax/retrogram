//! Queued/multithreaded analysis

use crate::analysis::dynamic::{analyze_trace_log, trace_until_fork};
use crate::analysis::error::Error;
use crate::analysis::fork::Fork;
use crate::analysis::passes::disassemble_block;
use crate::analysis::reference::ReferenceKind;
use crate::analysis::trace::Trace;
use crate::arch::{Architecture, CompatibleLiteral};
use crate::database::{Database, ProjectDatabase};
use crate::memory::{Memory, Offset, Pointer};
use crate::reg::State;
use num::Zero;
use rayon::Scope;
use std::convert::TryFrom;
use std::sync::mpsc::{channel, Receiver, Sender};
use std::sync::{Arc, RwLock};
use std::thread;

/// A command issued by some interactive thread into the analysis process.
///
/// Each command generates a subsequent `Response<AR>`. Responses will be
/// returned in any order in the response channel as the underlying work is
/// completed. Commands are permitted to issue multiple responses.
#[derive(Eq, PartialEq)]
pub enum Command<AR>
where
    AR: Architecture,
{
    /// Start a static scan at a given address.
    StaticScanCode(Pointer<AR::PtrVal>),

    /// Set the power-on state that all dynamic analysis in any future command
    /// will use.
    SetPowerOnState(State<AR>),

    /// Start a dynamic trace on a given address.
    DynamicScanCode(Fork<AR>),

    /// Execute all scans implied by the database.
    ///
    /// The `bool` parameter is `true` to indicate if dynamic scans should also
    /// be extracted.
    ///
    /// This command generates multiple responses: first, the number of scans
    /// that were found, followed by the responses generated by those scans.
    ///
    /// It is highly recommended to surround this command with fences so that
    /// you know that it has completed.
    ExtractAllScans(bool),

    /// Restrict the reordering of work such that all previously-issued
    /// commands have completed before any subsequently-issued commands are
    /// executed.
    ///
    /// This also emits a corresponding `Fence` response with the same
    /// reordering restriction on the responses for said work. You can use this
    /// response to determine when a given set of commands have completed.
    Fence,
}

pub enum Response<AR>
where
    AR: Architecture,
{
    /// Result of a static scan at a given address.
    StaticScanCode {
        /// The start of the scan.
        scan_start: Pointer<AR::PtrVal>,

        /// The length from the start to the end of the scan.
        ///
        /// A length of `None` signals a scan too long to represent as an
        /// `AR::Offset`.
        scan_end_offset: Option<AR::Offset>,

        /// The analysis error that occured analyzing the block, if any.
        error: Option<Error<AR>>,
    },

    /// Acknowledges that the power-on state was changed.
    PowerOnStateSet,

    /// Results of a dynamic trace at a given address.
    DynamicScanCode {
        /// The start of the scan.
        scan_start: Pointer<AR::PtrVal>,

        /// The end of the scan.
        scan_end: Pointer<AR::PtrVal>,

        /// The analysis error that occured tracing the block, if any.
        error: Option<Error<AR>>,
    },

    /// The number of scans extracted from the database.
    ///
    /// The first parameter indicates if the extract operation given allowed
    /// dynamic tracing.
    ///
    /// A count of zero indicates that scanning has completed. A non-zero count
    /// may indicate that further scans may be extractable from the database.
    ExtractScanCount(bool, usize),

    /// Acknowledges an issued `Fence` command, and restricts the reordering of
    /// responses as follows:
    ///
    /// 1. All responses before the `Fence` response originate from commands
    ///    before the acknowledged `Fence` command.
    /// 2. All responses after the `Fence` response originate from commands
    ///    after the acknowledged `Fence` response.
    ///
    /// It follows that one can determine if a command completed by issuing a
    /// `Fence` after it and waiting for it's response to come back.
    Fence,
}

/// The context for a given queue.
///
/// A queue cannot be started without a queue context, and each queue context
/// must refer to a single program. Each program has a separate queue.
#[derive(Clone)]
pub struct QueueContext<'a, 'scope, AR>
where
    AR: Architecture,
{
    /// The architecture to disassemble with.
    pub arch: AR,

    /// A mutable shared reference to the current analysis database.
    pub project_db: Arc<RwLock<ProjectDatabase>>,

    /// The name of the program this queue context services.
    pub program_name: String,

    /// An immutable reference to the current memory bus.
    ///
    /// Changes to program contents are not considered during the execution of
    /// Retrogram. Instead, any information derived from the program or changes
    /// intended to be made by the user must live inside the analysis database.
    pub bus: Arc<Memory<AR>>,

    /// The power-on state for any dynamic analysis.
    pub poweron_state: State<AR>,

    /// The Rayon scope which has generated
    scope: &'a Scope<'scope>,
}

impl<'a, 'scope, AR> QueueContext<'a, 'scope, AR>
where
    AR: Architecture,
{
    /// Spawn a new task into the Rayon scope held by this queue context.
    ///
    /// The given body closure will be provided a copy of this queue context
    /// with a fresh Rayon scope for further task spawning. The context may be
    /// mutated; however, no mutations will propagate up to this context, or to
    /// parent contexts.
    fn spawn<BODY>(&self, body: BODY)
    where
        BODY: for<'b> FnOnce(&mut QueueContext<'b, 'scope, AR>) + Send + 'scope,
        Memory<AR>: Send + Sync,
    {
        let arch = self.arch;
        let project_db = self.project_db.clone();
        let program_name = self.program_name.clone();
        let bus = self.bus.clone();
        let poweron_state = self.poweron_state.clone();

        self.scope.spawn(move |s| {
            let mut child_context = QueueContext {
                arch,
                project_db,
                program_name,
                bus,
                poweron_state,
                scope: s,
            };

            body(&mut child_context)
        });
    }

    /// Create a new Rayon scope with the same queue context and run a task
    /// inside it.
    ///
    /// This function blocks until the scope completes, and returns whatever
    /// result the inner function computes.
    ///
    /// The given body closure will be provided a copy of this queue context
    /// with a fresh Rayon scope for further task spawning. The context may be
    /// mutated; changes to the power-on state will propagate back to this
    /// context.
    fn scope<'scope2, BODY, R>(&mut self, body: BODY) -> R
    where
        BODY: for<'b> FnOnce(&mut QueueContext<'b, 'scope2, AR>) -> R + Send,
        R: Send,
        Memory<AR>: Send + Sync,
    {
        let arch = self.arch;
        let project_db = self.project_db.clone();
        let program_name = self.program_name.clone();
        let bus = self.bus.clone();
        let poweron_state = self.poweron_state.clone();

        let (result, mutated_poweron_state) = rayon::scope(|s| {
            let mut child_context = QueueContext {
                arch,
                project_db,
                program_name,
                bus,
                poweron_state,
                scope: s,
            };

            let result = body(&mut child_context);

            (result, child_context.poweron_state)
        });

        self.poweron_state = mutated_poweron_state;

        result
    }
}

/// Run a static disassembly on a particular location in the program.
///
/// All of the facts gleaned from the static disassembly will be inserted into
/// the context's associated database.
///
/// This function returns the length of the analyzed block and any error which
/// may have resulted during disassembly. The length will be `None` in the rare
/// case that the length of the block exceeds the maximum value of `AR::Offset`.
fn process_static_scan<L, AR>(
    context: &QueueContext<AR>,
    start: Pointer<AR::PtrVal>,
) -> Response<AR>
where
    AR: Architecture,
    L: CompatibleLiteral<AR>,
    AR::Offset: Offset<AR::PtrVal>, //I shouldn't have to do this.
{
    let (orig_asm, xrefs, pc_offset, blocks, terminating_error) =
        disassemble_block::<L, AR>(start.clone(), &context.bus, context.arch);

    let mut db_write = context.project_db.write().unwrap();
    let db = db_write.get_database_mut(&context.program_name).unwrap();

    for block in blocks {
        if let Some(_block_num) = db.find_block_membership(block.as_start()) {
            continue;
        }

        db.insert_block(block);
    }

    for xref in xrefs {
        if let Some(target) = xref.as_target() {
            if db.pointer_symbol(&target).is_none() {
                db.insert_placeholder_label(target.clone(), xref.kind());
            }

            if let Some(id) = db.find_block_membership(target) {
                let mut xref_offset = AR::Offset::zero();

                if let Some(block) = db.block(id) {
                    xref_offset = AR::Offset::try_from(
                        target.as_pointer().clone() - block.as_start().as_pointer().clone(),
                    )
                    .unwrap_or_else(|_| AR::Offset::zero());
                }

                if xref_offset > AR::Offset::zero() {
                    db.split_block(id, xref_offset);
                }
            }
        }

        db.insert_crossreference(xref);
    }

    //TODO: This seems to be polluting the symbol table for no reason.
    if let Some((_dir, loc)) = orig_asm.iter_directives().next() {
        db.insert_placeholder_label(loc.clone(), ReferenceKind::Unknown);
    }

    Response::StaticScanCode {
        scan_start: start,
        scan_end_offset: pc_offset,
        error: terminating_error,
    }
}

/// Run a static disassembly on a particular location in the program.
///
/// All of the facts gleaned from the static disassembly will be inserted into
/// the context's associated database.
///
/// This function returns the length of the analyzed block and any error which
/// may have resulted during disassembly. The length will be `None` in the rare
/// case that the length of the block exceeds the maximum value of `AR::Offset`.
fn process_dynamic_scan<L, AR>(context: &QueueContext<AR>, fork: Fork<AR>) -> Response<AR>
where
    AR: Architecture,
    L: CompatibleLiteral<AR>,
    AR::Offset: Offset<AR::PtrVal>, //I shouldn't have to do this.
    Memory<AR>: Send + Sync,
{
    let (branches, start, pre_state, pre_trace) = fork.into_parts();
    let start_ptr = pre_state.contextualize_pointer(start.clone());

    match trace_until_fork(&start, pre_trace, &context.bus, &pre_state, context.arch) {
        Ok((end, post_trace, post_state, prerequisites)) => {
            let end_ptr = post_state.contextualize_pointer(end.clone());

            let mut db_lock = context.project_db.write().unwrap();
            let db_mut: &mut Database<AR> =
                db_lock.get_database_mut(&context.program_name).unwrap();

            let traced_blocks =
                analyze_trace_log::<L, AR>(&post_trace, &context.bus, db_mut, context.arch);
            if let Err(e) = traced_blocks {
                return Response::DynamicScanCode {
                    scan_start: start_ptr,
                    scan_end: end_ptr,
                    error: Some(e),
                };
            }

            db_mut.insert_trace_counts(traced_blocks.unwrap(), 1);

            drop(db_lock);

            let mut extra_branch_bits = 0.0;
            for pr in prerequisites.iter() {
                extra_branch_bits += pr.necessary_forks(&post_state, &context.bus) as f64;
            }

            let extra_branches = (2.0_f64).powf(extra_branch_bits);

            if (branches + extra_branches) > (2.0_f64).powf(5.0) {
                //TODO: better heuristic please
                //TODO: this should retrieve the block's total fork score
                //TODO: what happens if we overtrace a block (say a utility fn)
                //      while it's still in the undertraced list?
                return Response::DynamicScanCode {
                    scan_start: start_ptr,
                    scan_end: end_ptr,
                    error: Some(Error::TraceTooDeep {
                        branches,
                        extra_branches,
                    }),
                };
            }

            for result_fork in Fork::make_forks(
                branches,
                end,
                post_state,
                &context.bus,
                Trace::begin_at(end_ptr.clone()),
                prerequisites.into_iter(),
            ) {
                context.spawn(|context| {
                    process_dynamic_scan::<L, AR>(context, result_fork);
                });
            }

            Response::DynamicScanCode {
                scan_start: start_ptr,
                scan_end: end_ptr,
                error: None,
            }
        }
        Err(e) => Response::DynamicScanCode {
            scan_start: start_ptr.clone(),
            scan_end: start_ptr,
            error: Some(e),
        },
    }
}

/// Search the given database for more things to scan, and scan them.
///
/// This function yields the number of commands it added to the database; if it
/// returns 0, then there was no additional work to extract from the database.
/// However, still-executing commands may create additional work. It is
/// recommended that this particular command be fenced off from previously
/// issued work.
pub fn extract_scans_from_database<L, AR>(
    context: &QueueContext<AR>,
    resp_sender: Sender<Response<AR>>,
    is_tracing_allowed: bool,
) -> Response<AR>
where
    AR: Architecture,
    L: CompatibleLiteral<AR>,
    Memory<AR>: Send + Sync,
{
    let db_lock = context.project_db.read().unwrap();
    let db: &Database<AR> = db_lock.get_database(&context.program_name).unwrap();
    let unanalyzed = db.unanalyzed_static_xrefs();
    let mut vcommands = Vec::new();

    for xref_id in unanalyzed {
        let mut target_pc = None;
        let xref = db.xref(xref_id);

        if let Some(xref) = xref {
            target_pc = xref.as_target().cloned();
        }

        if let Some(target_pc) = target_pc {
            if !db.has_target_failed_analysis(&target_pc) {
                vcommands.push(Command::StaticScanCode(target_pc));
            }
        }
    }

    if is_tracing_allowed {
        for block_id in db.undertraced_blocks().iter() {
            let block = db.block(*block_id).unwrap();

            let initial_fork = Fork::initial_fork(
                block.as_start().as_pointer().clone(),
                context.poweron_state.clone(),
            );
            vcommands.push(Command::DynamicScanCode(initial_fork));
        }
    }

    let sent_commands = vcommands.len();

    for command in vcommands {
        let my_resp_sender = resp_sender.clone();
        context.spawn(|context| {
            process_command::<L, AR>(context, command, my_resp_sender);
        });
    }

    Response::ExtractScanCount(is_tracing_allowed, sent_commands)
}

/// Spawn the given command into the context's Rayon scope.
///
/// This function returns `false` if it encounters a command fence, without
/// spawning any tasks. You should end the current scope and send the fence
/// response outside the scope.
fn process_command<L, AR>(
    context: &mut QueueContext<AR>,
    cmd: Command<AR>,
    resp_sender: Sender<Response<AR>>,
) -> bool
where
    AR: Architecture,
    L: CompatibleLiteral<AR>,
    Memory<AR>: Send + Sync,
{
    match cmd {
        Command::StaticScanCode(start) => {
            let my_sender = resp_sender;
            context.spawn(move |my_context| {
                my_sender
                    .send(process_static_scan::<L, AR>(&my_context, start))
                    .unwrap();
            });
            true
        }
        Command::SetPowerOnState(new_state) => {
            context.poweron_state = new_state;
            resp_sender.send(Response::PowerOnStateSet).unwrap();
            true
        }
        Command::DynamicScanCode(fork) => {
            let my_sender = resp_sender;
            context.spawn(move |my_context| {
                my_sender
                    .send(process_dynamic_scan::<L, AR>(&my_context, fork))
                    .unwrap();
            });
            true
        }
        Command::ExtractAllScans(is_tracing_allowed) => {
            let my_sender = resp_sender;
            context.spawn(move |my_context| {
                my_sender
                    .send(extract_scans_from_database::<L, AR>(
                        &my_context,
                        my_sender.clone(),
                        is_tracing_allowed,
                    ))
                    .unwrap();
            });
            true
        }
        Command::Fence => false,
    }
}

/// Start a separate analysis thread that performs analysis and returns
/// results of those analyses.
///
/// This function returns an MPSC channel sender that can be used for queueing
/// tasks for analysis, and a response reciever that responses will come back
/// from.
pub fn start_analysis_queue<L, AR>(
    arch: AR,
    project_db: Arc<RwLock<ProjectDatabase>>,
    program_name: String,
    bus: Arc<Memory<AR>>,
) -> (Sender<Command<AR>>, Receiver<Response<AR>>)
where
    AR: Architecture,
    L: CompatibleLiteral<AR>,
    Memory<AR>: Send + Sync,
{
    let (cmd_sender, mut cmd_recv) = channel();
    let (resp_sender, resp_recv) = channel();

    thread::spawn(move || {
        rayon::scope(move |s| {
            let mut emit_fence = false;
            let mut context = QueueContext {
                arch,
                project_db,
                program_name,
                bus,
                poweron_state: Default::default(),
                scope: s,
            };

            loop {
                let mut my_resp_sender = resp_sender.clone();

                // Process as many commands as possible before the next fence.
                // We use Rayon scopes as our fencing mechanism, which requires
                // some juggling between the inner scope and outer loop.
                let unmove = context.scope(|context| {
                    while let Ok(cmd) = cmd_recv.recv() {
                        if !process_command::<L, AR>(context, cmd, my_resp_sender.clone()) {
                            emit_fence = true;
                            break;
                        }
                    }

                    (cmd_recv, my_resp_sender)
                });

                cmd_recv = unmove.0;
                my_resp_sender = unmove.1;

                if emit_fence {
                    my_resp_sender.send(Response::Fence).unwrap();
                    emit_fence = false;
                } else {
                    // Can happen only if the scope terminated due to a
                    // `PoisonError`.
                    break;
                }
            }
        });
    });

    (cmd_sender, resp_recv)
}
